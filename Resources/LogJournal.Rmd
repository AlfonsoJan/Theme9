---
title: 'Log Journal Project Theme 9'
author: 'J.A. Busker (352905 BFV3)'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment=NA)
library(tidyr)
library(kableExtra)
library(ggplot2)
library(gridExtra)
library(cowplot)
library(ggpubr)
library(pander)
library(ggbiplot)
```

<!-- Copyright (c) 2022 John Busker. -->
<!-- Licensed under GPLv3. See gpl.md -->

---

The data has been retrived from [uci.](https://archive.ics.uci.edu/ml/datasets/Yeast) The dataset has been gathered of 1484 yeast sequences from SWISS-PROT using the annotations from YPD.

Attributes information:  

* **Sequence Name**: Accession number for the SWISS-PROT database.  
* **mcg**: McGeoch's method for signal sequence recognition.  
* **gvh**: von Heijne's method for signal sequence recognition.  
* **alm**: Score of the ALOM membrane spanning region prediction program.  
* **mit**: Score of discriminant analysis of the amino acid content of the N-terminal region (20 residues long) of mitochondrial and non-mitochondrial proteins.  
* **erl**: Presence of "HDEL" substring (thought to act as a signal for retention in the endoplasmic reticulum lumen). Binary attribute.  
* **pox**: Peroxisomal targeting signal in the C-terminus.  
* **vac**: Score of discriminant analysis of the amino acid content of vacuolar and extracellular proteins.  
* **nuc**: Score of discriminant analysis of nuclear localization signals of nuclear and non-nuclear proteins.  
* **Class Distribution**: The class is the localization site. Consisting of (abbreviation (full name) the amount):

--- ---------------------------------------------- ---
CYT (cytosolic or cytoskeletal)                    463  
NUC (nuclear)                                      429  
MIT (mitochondrial)                                244  
ME3 (membrane protein, no N-terminal signal)       163  
ME2 (membrane protein, uncleaved signal)            51  
ME1 (membrane protein, cleaved signal)              44  
EXC (extracellular)                                 37  
VAC (vacuolar)                                      30  
POX (peroxisomal)                                   20  
ERL (endoplasmic reticulum lumen)                    5  
--- ---------------------------------------------- --

Since there is not a codebook. I created my own codebook.

```{r}
attr_names <- c("seq.name", "mcg", "gvh", "alm", "mit", "erl",
                "pox", "vac","nuc", "loc.site" )

data_types <- c("str", "float", "float", "float", "float", "float",
                "bool", "float", "float", "factor")

data_labels <- c("Accession number for the SWISS-PROT database",
                 "McGeoch's method for signal sequence recognition",
                 "von Heijne's method for signal sequence recognition",
                 "Score of the ALOM membrane spanning region prediction program",
                 "Score of discriminant analysis of the amino 
                 acid content of the N-terminal region",
                 "Presence of 'HDEL' substring",
                 "Peroxisomal targeting signal in the C-terminus",
                 "Score of discriminant analysis of the amino acid content 
                 of vacuolar and extracellular proteins",
                 "Score of discriminant analysis of nuclear 
                 localization signals of nuclear and non-nuclear proteins",
                 "The class is the localization site")

codebook <- data.frame(Name=attr_names, 
                       Fullname=data_labels, 
                       Datatypes=data_types)

pander(codebook)
```

Here is the codebook. With the attributes abbreviation, explanation and data types. As you can see there are many float datatypes.

Now we need to load in the data. And change the column names to the attributes abbreviation, since these are non-existent. Let's give all the columns a name. And let's take a quick look at the data.

```{r}
data <- as_tibble(read.table("yeast.data", sep = ""))
colnames(data) <- attr_names
head(data)
```

We can drop the first columns since it is not necessary.

```{r}
data <- data[, -1]
head(data)
```

The first column has been succesfully dropped from the data.

We are going to look for any missing values.

```{r}
sum(is.na(data))
```

There are not any missing values.

Now we need to take a clearer look at the data set using `str()`

```{r}
str(data)
```

As you can see, the last column, loc.site, consists of characters, but this one needs to be converted to factors for clarity and complexity.

```{r}
data$loc.site <- as.factor(data$loc.site)
str(data$loc.site)
```

As you can see the data type of the column loc.site has been succesfully changed to factors.

The ERL variable also should be changed. As you can see, it is now a num data type but I needs to be a bool/binary datatype. Let's take a closer look at th ERL column.

```{r}
summary(data$erl)
```

This looks weird because the value should be 0 or 1.

There are alot of 0.5 values. But should not exist in this column. The variable need to be a bool, or in other words it must be a 0 or a 1. So all the 0.5 values needs to be changed to a 0.

```{r}
table(data[, "erl"])
```

Before the data transformation there are 1470 counts of the value 0.5 and 14 of 1.

```{r}
data$erl[data$erl == 0.5] <- 0
table(data[,"erl"])
```

The data has been succesfully transformed. Now the datatype has to be changed to a bool.

```{r}
data$erl <- as.logical(data$erl)
str(data$erl)
```

Now every column has the right datatype.

```{r}
p1 <- ggplot(data, mapping = aes(x = "", y = mcg)) + geom_violin(alpha=0.2) + 
  geom_jitter(width = 0.1, height = 0.1, alpha = 0.4, color = "red")

p2 <- ggplot(data, mapping = aes(x = "", y = gvh)) + geom_violin(alpha=0.2) + 
  geom_jitter(width = 0.2, height = 0.1, alpha = 0.4, color = "blue")

ggarrange(p1, p2, nrow = 1)
```


```{r}
p3 <- ggplot(data, mapping = aes(x = "", y = alm)) + geom_violin(alpha=0.2) + 
  geom_jitter(width = 0.1, height = 0.1, alpha = 0.4, color = "red")

p4 <- ggplot(data, mapping = aes(x = "", y = mit)) + geom_violin(alpha=0.2) + 
  geom_jitter(width = 0.2, height = 0.1, alpha = 0.4, color = "blue")

ggarrange(p3, p4, nrow = 1)
``` 

```{r}
p5 <- ggplot(data, mapping = aes(x = "", y = pox)) + geom_violin(alpha=0.2) + 
  geom_jitter(width = 0.2, height = 0.1, alpha = 0.4, color = "yellow")

p6 <- ggplot(data, mapping = aes(x = "", y = vac)) + geom_violin(alpha=0.2) + 
  geom_jitter(width = 0.2, height = 0.1, alpha = 0.4, color = "green")

ggarrange(p5, p6, nrow = 1)
```

```{r}
p1 <- ggplot(data, aes(x=mcg)) + geom_density(aes(color=loc.site)) + theme(legend.position = "none")
p2 <- ggplot(data, aes(x=gvh)) + geom_density(aes(color=loc.site)) + theme(legend.position = "none")
p3 <- ggplot(data, aes(x=alm)) + geom_density(aes(color=loc.site)) + theme(legend.position = "none")
p4 <- ggplot(data, aes(x=mit)) + geom_density(aes(color=loc.site)) + theme(legend.position = "none")
p5 <- ggplot(data, aes(x=pox)) + geom_density(aes(color=loc.site)) + theme(legend.position = "none")
p6 <- ggplot(data, aes(x=vac)) + geom_density(aes(color=loc.site)) + theme(legend.position = "none")
ggarrange(p1, p2, p3, p4, p5, p6, ncol=3, nrow=2, common.legend=TRUE, legend="right")
```



