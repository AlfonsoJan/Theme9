---
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyr)
library(knitr)
library(kableExtra)
library(pander)
library(ggplot2)
library(gridExtra)
library(ggpmisc)
library(ggpubr)
library(ggridges)
library(ggfortify)
```
# Result

To create a great dataset, changes need to be made to the downloaded dataset. The dataset consists of 1484 yeast sequences from SWISS-PROT using the annotations from YPD. In this section, we are going to talk about the results we found from the dataset.

## Codebook

As it is a large dataset, it is wise to look at the codebook first. However, there is no codebook. Nevertheless, there is a file with more information on all the attributes. This is where the information is extracted to make your own codebook.

Below is a table with a description of all the attributes' abbreviations, explanations, and data types.

```{r}
attr_names <- c("seq.name", "mcg", "gvh", "alm", "mit", "erl",
                "pox", "vac","nuc", "loc.site" )
data_types <- c("str", "double", "double", "double", "double", "double",
                "logical", "double", "double", "factor")
data_labels <- c("Accession number for the SWISS-PROT database",
                 "McGeoch's method for signal sequence recognition",
                 "von Heijne's method for signal sequence recognition",
                 "Score of the ALOM membrane spanning region prediction program",
                 "Score of discriminant analysis of the amino 
                 acid content of the N-terminal region",
                 "Presence of 'HDEL' substring",
                 "Peroxisomal targeting signal in the C-terminus",
                 "Score of discriminant analysis of the amino acid content 
                 of vacuolar and extracellular proteins",
                 "Score of discriminant analysis of nuclear 
                 localization signals of nuclear and non-nuclear proteins",
                 "The class is the localization site")
codebook <- data.frame(Name=attr_names, 
                       Fullname=data_labels, 
                       Datatypes=data_types)
kbl(codebook, booktabs = T, align = "c") %>%
  kable_styling(full_width = T) %>%
  column_spec(2, width = "10cm")
```

\begin{center}
\emph{Table 1:} The codebook.
\end{center}

The last column is the sequence's localization site. There are ten different possibilities for this. Yeast proteins were classified into ten classes: **cytoplasmic:** cytoskeletal (CYT); nuc]ear (NUC); vacuolar (VAC); mitochondrial (MIT); isomal (POX); **extracellular:** including those localized against the cell wall (EXC); proteins localized to the lumen of the endoplasmic reticulum (ERL); membrane proteins with a cleaved signal (ME1); membrane proteins with an uncleared signal (ME2); and membrane proteins with no N-terminal sign (ME3), where ME1, ME2,and ME3 proteins may be localized to the plasma membrane, the endoplasmic reticulum membrane, or the membrane of a golgi body. 

Here are the ten in question:

```{r}
abbrv <- c("CYT", "NUC", "MIT", "ME3", "ME2", "ME1", "EXC", "VAC", "POX", "ERL")
loc.fullname <- c("cytosolic or cytoskeletal", "nuclear", "mitochondrial", "membrane protein, no N-terminal signal", "membrane protein, uncleaved signal", "membrane protein, cleaved signal", "extracellular", "vacuolar", "peroxisomal", "endoplasmic reticulum lumen")
amount <- c(463, 429, 244, 163, 51, 44, 37, 30, 20, 5)
pander(data.frame(Abbreviation=abbrv, 
                  Fullname=loc.fullname, 
                  Amount=amount))
```

\begin{center}
\emph{Table 2:} Sequence localization sites.
\end{center}

There are alot of CYT and NUC localizations. ERL localization is the least. There are only five of these in the dataset.

## Dataset

Eight features were used in classification: the presence or absence of an HDEL pattern as a signal for retention in the endoplasmic reticulum lumen (erl); The results of discriminant analysis on the amino acid content of vacuolar and extracellular proteins (vac); the result of discriminant analysis on the amino acid composition of the 20-residue N-terminal region of mitochondrial and non-mitochondrial proteins (mit); the presence or absence of nuclear localization consensus patterns combined with a term reflecting the frequency of basic residues (nuc); and some combination of the presence of a short sequence motif and the result of discriminant analysis of the amino acid composition of the protein sequence (pox).

```{r}
data <- as_tibble(read.table("yeast.data", sep = ""))
colnames(data) <- attr_names
pander(head(data))
```

\begin{center}
\emph{Table 3:} First six rows of the dataset.
\end{center}

As seen from the table, the loaded dataset. It has a char datatype for the first and last column. And every other column has a double datatype.

There are `r nrow(data)` rows and `r ncol(data)` columns.

\newpage

```{r, fig.cap="A waffle chart of the categorical composition", fig.width=6, fig.height=3}
df <- expand.grid(y = 1:28, x = 1:53)
categ_table <- sort(table(data$loc.site), decreasing = T)
df$category <- factor(rep(names(categ_table), categ_table))
ggplot(df, aes(x = x, y = y, fill = category)) +
geom_tile(color = "black", size = 0.5) +
scale_x_continuous(expand = c(0, 0)) +
scale_y_continuous(expand = c(0, 0), trans = 'reverse') +
scale_fill_brewer(palette = "Set3") +
labs(title="Waffle Chart", subtitle="'Class' of localization") +
xlab(NULL) + ylab(NULL)
```

Figure 1 shows the number of each classification of the dataset. There are alot of CYT and NUC localization. And there are only `r nrow(subset(data, loc.site=="ERL", loc.site))` of ERL.

## Clean the data

To ensure the quality of the data. The data had to be transformed before it could be worked with.

The first column has been dropped since it is not necessary. Since the sequence names contribute nothing to creating a prediction model.

```{r}
data <- data[, -1]
pander(head(data))
```

\begin{center}
\emph{Table 4:} First six rows of the dataset with the first column dropped.
\end{center}

As stated on the website there are `r sum(is.na(data))` missing values.

```{r}
data$loc.site <- as.factor(data$loc.site)
str(data$loc.site)
```

The data type of the column loc.site has been successfully changed to factors.

The ERL column has changed. from a double to a logical datatype. As seen in figure 2 below, only numbers 1 and 0.5 appear, but for a logical datatype you need 1 and 0. All 0.5 have been changed to 0.

\newpage

```{r, warning=FALSE, message=FALSE, fig.cap="ERL column data distrubution", fig.width=10, fig.height=4}
my_list <- as.data.frame(table(data[,"erl"]))
names(my_list) <- c("Values", "Freq")
ggplot(data, mapping = aes(x = "", y = erl)) + geom_violin(alpha=0.2) + geom_jitter(width = 0.5, alpha = 0.25, height = 0.005, color = "red") + xlab(NULL) + annotate(geom = "table", x = 0.5, y = 0.75, label = list(my_list)) + ylim(0, 1) + labs(title="ERL Variable", subtitle="Data distrubution")
```

```{r}
data$erl[data$erl == 0.5] <- 0
data$erl <- as.logical(data$erl)
m <- sapply(data, typeof)
m[m=="integer"] <- "factor"
pander(m)
```

\begin{center}
\emph{Table 5:} Each column name and the typeof the datatype.
\end{center}

Each column has been changed so that it has the right data type.

## Exploratory data analysis

```{r}
table <- summary(data[, -c(5,9)])
panderOptions('table.continues', '')
pander(table)
```

\begin{center}
\emph{Table 6:} Summary of the dataset.
\end{center}

As observed in table 6 the data has already been transformed with a min-max normalisation. All the datapoints are between 0 and 1. Mcg and gvh are normally distributed. Alm and mit are skewed, but nothing too crazy to be worried about. Vac and nuc are really skewed. However, it's not yet bad enough to worry about it. Pox is very oddly distributed.

\newpage

```{r, fig.cap="Closer look at the pox variable", fig.width=10, fig.height=4}
my_list <- as.data.frame(table(data[,"pox"]))
names(my_list) <- c("Values", "Freq")
p1 <- ggplot(data, mapping = aes(x = "", y = pox)) + geom_violin(alpha=0.2) + 
  geom_jitter(width = 0.5, alpha = 0.25, height = 0.005, color = "red") + xlab(NULL)
p1 + annotate(geom = "table", x = 0.5, y = 0.75, label = list(my_list)) + labs(title="Pox Variable", subtitle="Data distrubution")
```

Almost all the data points are 0. This could cause problems later on. Since more than 95% of all the data points are 0.

```{r, fig.cap="Frequency plot of pox variablee", fig.height=3}
d <- as.data.frame(table(subset(data, pox > 0, select=loc.site)))
ggplot(d, aes(Var1, Freq)) +
  geom_linerange(
    aes(x = Var1, ymin = 0, ymax = Freq), 
    color = "lightgray", size = 1.5
    )+
  geom_point(aes(color = Var1), size = 2) + labs(title="Frequency plot of pox variable", x="localization site", y = "Count")
```

If the pox value is not zero then the classification is Pox, Mit or Cyt. This means that Pox has a high probability when the Pox value is not zero.

With a heatmap, you can easily see where there are correlations between variables.

```{r}
cor_matrix <- cor(data[, -c(5,9)])
cor_matrix <- as_tibble(cor_matrix)
cor_matrix <- cor_matrix %>% mutate(varnames = all_of(attr_names)[-c(1,6,10)])
kbl(cor_matrix, booktabs = T, align = "c") %>%
  kable_styling(full_width = T)
```

\begin{center}
\emph{Table 7:} The calculated correlation matrix.
\end{center}

This has been transformed into a long matrix.

```{r}
cor_matrix_long <- pivot_longer(data = cor_matrix, 
                                 cols = all_of(attr_names)[-c(1,6,10)], 
                                 names_to = "variable", values_to = "cor")
pander(head(cor_matrix_long))
```

\begin{center}
\emph{Table 8:} The long calculated correlation matrix.
\end{center}

```{r, fig.cap="A heatmap pairwise correlation of selected numeric variables", fig.height=4}

ggplot(data = cor_matrix_long, aes(x=varnames, y=variable, fill=cor)) + 
    geom_tile() + 
    labs(x=NULL, y=NULL, title="Heatmap Correlation") + 
    scale_fill_gradient(high = "purple", low = "white" )
```

As seen from the heatmap, there is some correlation between mcg and gvh. Pox, on the other hand, has almost no correlation with any other variable.

There needs to be data correlation with the classes. The height of the peak doesn’t matter much, shifted peaks do.

```{r, warning=FALSE, message=FALSE, fig.cap="Ridge line plot between mcg and gvh"}
p1 <- ggplot(data, aes(x=mcg, y=loc.site, fill = loc.site)) + 
  geom_density_ridges2(rel_min_height = 0.005) + theme_minimal() + 
  coord_cartesian(clip = "off")
p2 <- ggplot(data, aes(x=gvh, y=loc.site, fill = loc.site)) + 
  geom_density_ridges2(rel_min_height = 0.005) + theme_minimal() + 
  coord_cartesian(clip = "off")
plot <- ggarrange(p1, p2, common.legend = TRUE)
annotate_figure(plot, top = text_grob("Ridge line plot", face = "bold", size = 14))
```

There are shifted peaks. This shows the distribution of the different classes.

A 1-way ANOVA test was carried out on the data.

```{r}
# Perform a one way anova test
res.aov <- summary(aov(mcg ~ loc.site, data = data))
p.value <- res.aov[[1]]$`Pr(>F)`[1]
```

The P-value: `r p.value` is < 0.05. So there is a significant difference.

\newpage

```{r, fig.cap="Classical (Metric) Multidimensional Scaling", fig.width=4, fig.height=2.5}
matrix <- with(data, rbind(mcg, gvh, alm, mit, pox, vac, nuc))
distmat <- dist(matrix)
autoplot(cmdscale(distmat, eig = TRUE), shape = FALSE, label = TRUE, label.size = 4)
```

As found in the heatmap, Mcg and Gvh are clustered. Vac and Alm are somewhat clustered; they are close to each other. Nuc, Mit and Pox are all on their own.

```{r, fig.cap="PCA plot", fig.width=6, fig.height=3}
df <- data[-c(5,9)]

pca_res <- prcomp(df, scale. = TRUE)

autoplot(pca_res, data = data, colour = 'loc.site', loadings = TRUE, loadings.label = TRUE)
```

Mcg and Gvh are also clustered in this PCA plot. As such, in contrast with the MDS plot, Vac and Alm are not clustered at all. Pox is in the centre.

\newpage

# Discussion & Conclusion

The research question is: can machine learning predict protein localization based on their aminoacid sequences? And to answer this question properly, a clean dataset is needed to create a model. The results will show what is wrong with the data and the correlations between the different classifications. The results are not completely trustworthy because there is too little of them. Namely, there are only 1484 oberservations. This is too few for prediction with 10 different classifications.

## Discussion

Nor was the Erl column considered. This indicates the presence of the "HDEL" substring. If this had been looked at, more correlations would have emerged. Which could later become significant. There was also something wrong with the ERL column. As stated on the site, it is a binary/logical type. Either 0 or 1. It is present or it is not present. However, there were only values of 0.5 and 1. All values of 0.5 were changed to 0.

In the case of the Pox column, something strange was noticed. Out of 1484 datapoints, 15 are not zero. 11 of them have the classification of Pox. This means that if the value is not zero, the classification is highly probable Pox.

## Conclusion

The aim was to create a clean dataset to be used for our machine learning project. There is a clean dataset with no missing values and the correct data types. The data gives a clear overview of the protein classification and their attributes. However, not much was available. With only 1484 observations, this is just too little. And there is a very big difference between the number of observations per classification. For ERL there are only 5 observations, and for CYT there are 463. There is too big a difference between these. By improving this dataset over time, the prediction can be perfected even more. These constant improvements are important to find.